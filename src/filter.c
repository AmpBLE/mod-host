/*
 * This file is part of mod-host.
 *
 * mod-host is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * mod-host is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with mod-host.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
************************************************************************************************************************
*
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           INCLUDE FILES
************************************************************************************************************************
*/

#include <math.h>
#include "filter.h"

/*
************************************************************************************************************************
*           LOCAL DEFINES
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           LOCAL CONSTANTS
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           LOCAL DATA TYPES
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           LOCAL MACROS
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           LOCAL GLOBAL VARIABLES
************************************************************************************************************************
*/

const unsigned int filter_order = 96;
static double delta_t[96] = { 0.0 }; // all elements 0.0

/*
************************************************************************************************************************
*           LOCAL FUNCTION PROTOTYPES
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           LOCAL CONFIGURATION ERRORS
************************************************************************************************************************
*/


/*
************************************************************************************************************************
*           LOCAL FUNCTIONS
************************************************************************************************************************
*/

/**
 * Calculate the BPM from the time difference of two adjacent MIDI
 * Beat Clock signals.
 * 
 * `delta_t` is time in samples. Due to filtering, this is not integer.
 */
float beats_per_minute(const float delta_t, const jack_nframes_t sample_rate) {
  /*
   * \text{bpm} = \frac{120}{2\cdot{}24}\cdot{}\cfrac{\text{SR}}{\delta t}
   */  
  return (2.5 * (sample_rate)) / delta_t;
}

/**
 * `raw_delta_t` is the time difference in samples between two
 * adjacent MIDI Beat Clock ticks. Over time this has jitter. This
 * function filters the jitter and returns a more steady time delta.
 *
 * Currently this filter is implemented as a centered binomial FIR
 * filter.
 */
float beat_clock_tick_filter(unsigned long long raw_delta_t) {
  float result = 0.0;

  /* These coefficients were calculated using the following Python
   * script:
   *
   * # Pascal's triangle as binomial coefficients, but normalized such that the sum is 1.
   * # Print the k-th row of the triangle:
   * def normalized_binomial_coefficients(k):
   *     coeffs = []
   *     for i in range(k-1, k):
   *         for n in range(0, i+1):
   *             coeffs.append(scipy.special.comb(i, n, exact=True))
   *     s = sum(coeffs)
   *     print([e/s for e in coeffs])
   *
   * normalized_binomial_coefficients(96)
   */  
  const double coeffs[] = {
2.524354896707238e-29, 2.398137151871876e-27, 1.1271244613797817e-25, 3.494085830277323e-24, 8.036397409637843e-23, 1.4626243285540875e-21, 2.1939364928311312e-20, 2.7894335408852954e-19, 3.068376894973825e-18, 2.966097665141364e-17, 2.550843992021573e-16, 1.9711067211075792e-15, 1.3797747047753055e-14, 8.809330807411566e-14, 5.159750901483917e-13, 2.7862654868013153e-12, 1.3931327434006575e-11, 6.473969807567762e-11, 2.805386916612697e-10, 1.1369199609430404e-09, 4.320295851583553e-09, 1.542962804136983e-08, 5.189965795733489e-08, 1.6472500134284552e-07, 4.941750040285366e-07, 1.403457011441044e-06, 3.778538107725887e-06, 9.656264053077267e-06, 2.3450926986044793e-05, 5.4179727864310386e-05, 0.00011919540130148285, 0.0002499258414385931, 0.0004998516828771862, 0.0009542623036746281, 0.0017401253772890276, 0.0030327899432751626, 0.0050546499054586035, 0.008060117416812368, 0.012302284478292562, 0.017980261929812207, 0.02517236670173709, 0.033767808990135116, 0.04341575441588801, 0.05351244148935034, 0.06324197630559586, 0.07167423981300863, 0.07790678240544417, 0.08122196463546306, 0.08122196463546306, 0.07790678240544417, 0.07167423981300863, 0.06324197630559586, 0.05351244148935034, 0.04341575441588801, 0.033767808990135116, 0.02517236670173709, 0.017980261929812207, 0.012302284478292562, 0.008060117416812368, 0.0050546499054586035, 0.0030327899432751626, 0.0017401253772890276, 0.0009542623036746281, 0.0004998516828771862, 0.0002499258414385931, 0.00011919540130148285, 5.4179727864310386e-05, 2.3450926986044793e-05, 9.656264053077267e-06, 3.778538107725887e-06, 1.403457011441044e-06, 4.941750040285366e-07, 1.6472500134284552e-07, 5.189965795733489e-08, 1.542962804136983e-08, 4.320295851583553e-09, 1.1369199609430404e-09, 2.805386916612697e-10, 6.473969807567762e-11, 1.3931327434006575e-11, 2.7862654868013153e-12, 5.159750901483917e-13, 8.809330807411566e-14, 1.3797747047753055e-14, 1.9711067211075792e-15, 2.550843992021573e-16, 2.966097665141364e-17, 3.068376894973825e-18, 2.7894335408852954e-19, 2.1939364928311312e-20, 1.4626243285540875e-21, 8.036397409637843e-23, 3.494085830277323e-24, 1.1271244613797817e-25, 2.398137151871876e-27, 2.524354896707238e-29
  };
  
  // Shift
  for (unsigned int i = filter_order-1; i >= 1; --i) {
    delta_t[i] = delta_t[i-1];
  }  
  delta_t[0] = raw_delta_t;
  
  // Summing up. TODO: This can be optimized in regards to rounding
  // errors. Just sum up the small coefficients first.
  for (unsigned int i = 0; i < filter_order; ++i) {
    result += coeffs[i] * delta_t[i];
  }
  return result;
}
